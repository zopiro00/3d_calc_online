const express = require('express');
const multer = require('multer');
const cors = require('cors');
const path = require('path');
const fs = require('fs');
const { exec } = require('child_process');
const app = express();
require('dotenv').config();

// Validate Environment Variables
const REQUIRED_ENV_VARS = ['PRUSA_SLICER_PATH', 'PORT'];

REQUIRED_ENV_VARS.forEach((envVar) => {
  if (!process.env[envVar]) {
    console.error(`ERROR: Missing required environment variable: ${envVar}`);
    process.exit(1); // Exit the application if a required variable is missing
  }
});

// Environment variables from .env file
const PRUSA_SLICER_PATH = process.env.PRUSA_SLICER_PATH;
const PORT = process.env.PORT || 5001;

// Function to escape file paths for CLI commands
const escapePath = (filePath) => filePath.replace(/ /g, '\\ ');

// Creates a config file to send to the prusa slicer based on the parameters selected in the front.
const generateConfig = (quality, supports) => {
  const configPath = path.resolve('uploads/config.ini'); // Path to save the config file

  // Map quality to PrusaSlicer settings
  const qualitySettings = {
    low: '0.3', // 0.3 mm layer height for low quality
    medium: '0.2', // 0.2 mm layer height for medium quality
    high: '0.1', // 0.1 mm layer height for high quality
  };

  // Check for valid quality
  if (!qualitySettings[quality]) {
    throw new Error('Invalid quality setting. Choose low, medium, or high.');
  }

  // Generate the content of the config file
  const configContent = `# Generated by 3D Print Price Calculator
layer_height = ${qualitySettings[quality]}
support_material = ${supports === 'yes' ? 1 : 0}
`;

  // Write the config file
  fs.writeFileSync(configPath, configContent, 'utf8');
  console.log('Configuration file generated at:', configPath);

  return configPath; // Return the path to the config file
};

// Processes the GCODE File to obtain the estimated time and filament used
const parseGCodeForTimeAndFilament = (gcodePath) => {
  return new Promise((resolve, reject) => {
    fs.readFile(gcodePath, 'utf8', (err, data) => {
      if (err) {
        console.error('Error reading G-code file:', err.message);
        return reject('Failed to read G-code file');
      }

      // Search for the estimated printing time
      const timeMatch = data.match(
        /; estimated printing time \(normal mode\) = (\d+h \d+m \d+s)/i
      );
      const estimatedTime = timeMatch ? timeMatch[1] : 'Unknown';

      // Search for the filament used
      const filamentMatch = data.match(/; filament used \[mm\] = ([\d.]+)/i);
      const filamentUsed = filamentMatch ? parseFloat(filamentMatch[1]) : 0;

      console.log('Estimated time parsed from G-code:', estimatedTime);
      console.log('Filament used parsed from G-code:', filamentUsed);

      resolve({ estimatedTime, filamentUsed });
    });
  });
};

// Pricing logic based on material, quality, and supports
const calculatePrice = (
  { filamentUsed, estimatedTime },
  material,
  quality,
  supports
) => {
  // Material costs (per cubic centimetre)
  const materialCosts = {
    PLA: 0.05,
    ABS: 0.07,
    PETG: 0.06,
  };

  // Machine time cost (per hour)
  const machineTimeCostPerHour = 1.5;

  // Quality multiplier for machine time
  const qualityMultiplier = {
    low: 0.8, // Low quality is faster
    medium: 1.0, // Default speed
    high: 1.2, // High quality takes longer
  };

  // Convert filament length (mm) to weight (grams)
  const filamentDiameter = 1.75; // mm
  const filamentDensity = 1.24; // g/cm³ (PLA as default)
  const filamentVolume =
    (Math.PI * Math.pow(filamentDiameter / 2, 2) * filamentUsed) / 1000; // cm³
  const filamentWeight = filamentVolume * filamentDensity; // grams

  // Calculate the material cost
  const materialCost = filamentWeight * (materialCosts[material] || 0.02); // Default cost if material is unknown

  // Parse estimated time into hours (e.g., "1h 30m 20s")
  const timeMatch = estimatedTime.match(/(\d+)h (\d+)m (\d+)s/);
  const hours =
    timeMatch && timeMatch.length === 4
      ? parseInt(timeMatch[1]) +
        parseInt(timeMatch[2]) / 60 +
        parseInt(timeMatch[3]) / 3600
      : 0;

  // Calculate the machine usage cost
  const machineUsageCost =
    hours * machineTimeCostPerHour * qualityMultiplier[quality.toLowerCase()];

  // Support material cost (10% extra material cost if supports are used)
  const supportCost = supports.toLowerCase() === 'yes' ? materialCost * 0.1 : 0;

  // Total price
  const totalPrice = materialCost + machineUsageCost + supportCost;

  console.log('>> Calculated Price Breakdown:', {
    filamentWeight,
    materialCost,
    machineUsageCost,
    supportCost,
    totalPrice,
  });

  return totalPrice.toFixed(2); // Return total price rounded to 2 decimals
};

// This function enables PrusaSlicer to calculate the price using the software
const runPrusaSlicer = (filePath, configPath) => {
  return new Promise((resolve, reject) => {
    const absoluteFilePath = path.resolve(filePath);
    const outputGCodePath = absoluteFilePath.replace('.stl', '.gcode'); // Output G-code file
    const command = `"${PRUSA_SLICER_PATH}" --slice --output "${outputGCodePath}" --load "${configPath}" "${absoluteFilePath}"`;

    console.log(`Executing slicing command: ${command}`);

    exec(command, (error, stdout, stderr) => {
      if (error) {
        console.error('Slicing error:', error.message);
        return reject(error);
      }
      if (stderr) {
        console.warn('PrusaSlicer stderr:', stderr);
      }

      console.log('>> Slicing output:', stdout);

      // After slicing, parse the G-code for estimated time and filament used
      parseGCodeForTimeAndFilament(outputGCodePath)
        .then(({ estimatedTime, filamentUsed }) => {
          resolve({ estimatedTime, filamentUsed, outputGCodePath });
        })
        .catch((parseError) => {
          console.error('XX Failed to parse G-code data:', parseError);
          resolve({
            estimatedTime: 'Unknown',
            filamentUsed: 0,
            outputGCodePath,
          });
        });
    });
  });
};

// Enable CORS
app.use(
  cors({
    origin: 'http://localhost:3000', // Allow requests only from your frontend
    methods: ['GET', 'POST'], // Allow specific methods
    allowedHeaders: ['Content-Type'], // Allow specific headers
  })
);

// Configure multer for file uploads
const upload = multer({ dest: 'uploads/' });

// Endpoint to handle file uploads and parameter processing
app.post('/calculate', upload.single('file'), async (req, res) => {
  try {
    const file = req.file;
    const { material = 'PLA', quality = 'medium', supports = 'no' } = req.body;

    console.log('>> File received:', file);
    console.log('>> Parameters:', { material, quality, supports });

    if (!file) {
      return res.status(400).json({ error: 'No file uploaded.' });
    }

    // Validate file extension
    const validExtensions = ['stl', 'obj', '3mf'];
    const fileExtension = file.originalname.split('.').pop().toLowerCase();
    if (!validExtensions.includes(fileExtension)) {
      return res.status(400).json({
        error:
          'XX Unsupported file format. Please upload a .stl, .obj, or .3mf file.',
      });
    }

    // Rename the file to include the correct extension
    const newFilePath = `${file.path}.${fileExtension}`;
    fs.renameSync(file.path, newFilePath);
    console.log('>> File renamed to:', newFilePath);

    const absoluteFilePath = path.resolve(newFilePath);
    console.log('>> Absolute file path:', absoluteFilePath);

    // Check if the file exists before proceeding
    if (!fs.existsSync(absoluteFilePath)) {
      console.error('>> File does not exist at:', absoluteFilePath);
      return res.status(400).json({
        error: '>> File does not exist. PrusaSlicer cannot process it.',
      });
    }

    // Generate configuration file based on parameters
    const configPath = generateConfig(
      quality.toLowerCase(),
      supports.toLowerCase()
    );

    // Run PrusaSlicer and get output
    const { estimatedTime, filamentUsed, outputGCodePath } =
      await runPrusaSlicer(newFilePath, configPath);

    // Calculate price
    const totalPrice = calculatePrice(
      { filamentUsed, estimatedTime },
      material,
      quality,
      supports
    );

    // Send response
    res.json({
      message: 'Slicing complete',
      estimatedTime,
      filamentUsed,
      totalPrice,
    });

    // Clean up files
    Promise.all([
      fs.promises
        .unlink(newFilePath)
        .catch((err) =>
          console.error('Error deleting input file:', err.message)
        ),
      fs.promises
        .unlink(outputGCodePath)
        .catch((err) =>
          console.error('Error deleting G-code file:', err.message)
        ),
      fs.promises
        .unlink(configPath)
        .catch((err) =>
          console.error('Error deleting config file:', err.message)
        ),
    ]).then(() => {
      console.log('All temporary files cleaned up.');
    });
  } catch (error) {
    console.error('XX Error in /calculate route:', error.message);
    res.status(500).json({ error: 'Internal Server Error' });
  }
});

app.get('/', (req, res) => {
  res.send('Welcome to the 3D Print Price Calculator Backend!');
});

// Start the server
app.listen(PORT, () => {
  console.log(`Backend server running on http://localhost:${PORT}`);
});
