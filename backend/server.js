const express = require('express');
const multer = require('multer');
const cors = require('cors');
const path = require('path');
const fs = require('fs');
const { exec } = require('child_process');

const app = express();
require('dotenv').config();
const PORT = process.env.PORT || 5001;

// Function to escape file paths for CLI commands
const escapePath = (filePath) => filePath.replace(/ /g, '\\ ');

// Creates a config file to send to the prusa slicer based on the parameters selected in the front.
const generateConfig = (quality, supports) => {
  const configPath = path.resolve('uploads/config.ini'); // Path to save the config file

  // Map quality to PrusaSlicer settings
  const qualitySettings = {
    low: '0.3', // 0.3 mm layer height for low quality
    medium: '0.2', // 0.2 mm layer height for medium quality
    high: '0.1', // 0.1 mm layer height for high quality
  };

  // Check for valid quality
  if (!qualitySettings[quality]) {
    throw new Error('Invalid quality setting. Choose low, medium, or high.');
  }

  // Generate the content of the config file
  const configContent = `# Generated by 3D Print Price Calculator
layer_height = ${qualitySettings[quality]}
support_material = ${supports === 'yes' ? 1 : 0}
`;

  // Write the config file
  fs.writeFileSync(configPath, configContent, 'utf8');
  console.log('Configuration file generated at:', configPath);

  return configPath; // Return the path to the config file
};

// Processes the GCODE File to obtain the estimated time of the printing.
const parseGCodeForTime = (gcodePath) => {
  return new Promise((resolve, reject) => {
    fs.readFile(gcodePath, 'utf8', (err, data) => {
      if (err) {
        console.error('Error reading G-code file:', err.message);
        return reject('Failed to read G-code file');
      }

      // Search for the estimated printing time
      const timeMatch = data.match(
        /; estimated printing time \(normal mode\) = (\d+h \d+m \d+s)/i
      );
      const estimatedTime = timeMatch ? timeMatch[1] : 'Unknown';

      console.log('Estimated time parsed from G-code:', estimatedTime);
      resolve(estimatedTime);
    });
  });
};

// This function enables PrusaSlicer to calculate the price using the software
const runPrusaSlicer = (filePath, configPath) => {
  return new Promise((resolve, reject) => {
    const absoluteFilePath = path.resolve(filePath);
    const outputGCodePath = absoluteFilePath.replace('.stl', '.gcode'); // Output G-code file
    const command = `"/Applications/Original Prusa Drivers/PrusaSlicer.app/Contents/MacOS/PrusaSlicer" --slice --output "${outputGCodePath}" --load "${configPath}" "${absoluteFilePath}"`;

    console.log(`Executing slicing command: ${command}`);

    exec(command, (error, stdout, stderr) => {
      if (error) {
        console.error('Slicing error:', error.message);
        return reject(error);
      }
      if (stderr) {
        console.warn('PrusaSlicer stderr:', stderr);
      }

      console.log('>> Slicing output:', stdout);

      // After slicing, parse the G-code for estimated time
      parseGCodeForTime(outputGCodePath)
        .then((estimatedTime) => {
          resolve({ estimatedTime, outputGCodePath });
          console.log('>> Estimated printing time:', estimatedTime);
        })
        .catch((parseError) => {
          console.error('XX Failed to parse estimated time:', parseError);
          resolve({ estimatedTime: 'Unknown', outputGCodePath });
        });
    });
  });
};

// Enable CORS
app.use(
  cors({
    origin: 'http://localhost:3000', // Allow requests only from your frontend
    methods: ['GET', 'POST'], // Allow specific methods
    allowedHeaders: ['Content-Type'], // Allow specific headers
  })
);

// Configure multer for file uploads
const upload = multer({ dest: 'uploads/' });

// Endpoint to handle file uploads and parameter processing
app.post('/calculate', upload.single('file'), async (req, res) => {
  try {
    const file = req.file;
    const { material, quality, supports } = req.body;

    console.log('>> File received:', file);
    console.log('>> Parameters:', { material, quality, supports });

    if (!file) {
      return res.status(400).json({ error: 'No file uploaded.' });
    }

    // Validate file extension
    const validExtensions = ['stl', 'obj', '3mf'];
    const fileExtension = file.originalname.split('.').pop().toLowerCase();
    if (!validExtensions.includes(fileExtension)) {
      return res.status(400).json({
        error:
          'XX Unsupported file format. Please upload a .stl, .obj, or .3mf file.',
      });
    }

    // Rename the file to include the correct extension
    const newFilePath = `${file.path}.${fileExtension}`;
    fs.renameSync(file.path, newFilePath);
    console.log('>> File renamed to:', newFilePath);

    const absoluteFilePath = path.resolve(newFilePath);
    console.log('>> Absolute file path:', absoluteFilePath);

    // Check if the file exists before proceeding
    if (!fs.existsSync(absoluteFilePath)) {
      console.error('>> File does not exist at:', absoluteFilePath);
      return res.status(400).json({
        error: '>> File does not exist. PrusaSlicer cannot process it.',
      });
    }

    // Generate configuration file based on parameters
    const configPath = generateConfig(
      quality.toLowerCase(),
      supports.toLowerCase()
    );

    // Run PrusaSlicer and get output
    const { estimatedTime, outputGCodePath } = await runPrusaSlicer(
      newFilePath,
      configPath
    );

    // Placeholder for parsing output (to be implemented later)
    console.log(
      '>> Slicer Output: Slicing complete, result stored in:',
      outputGCodePath
    );
    const parsedData = {}; // Replace with actual parsing logic. Solved through Run prusa?

    // Placeholder for pricing logic (to be implemented later)
    const totalPrice = 0; // Replace with actual pricing calculation logic

    /// Send response
    res.json({
      message: 'Slicing complete',
      estimatedTime,
      outputGCodePath,
    });

    // Clean up files
    fs.unlink(newFilePath, (err) => {
      if (err) console.error('XX Error deleting input file:', err.message);
    });
    fs.unlink(outputGCodePath, (err) => {
      if (err) console.error('XX Error deleting G-code file:', err.message);
    });
    fs.unlink(configPath, (err) => {
      if (err) console.error('XX Error deleting config file:', err.message);
    });
  } catch (error) {
    console.error('XX Error in /calculate route:', error.message);
    res.status(500).json({ error: 'Internal Server Error' });
  }
});

app.get('/', (req, res) => {
  res.send('Welcome to the 3D Print Price Calculator Backend!');
});

// Start the server
app.listen(PORT, () => {
  console.log(`Backend server running on http://localhost:${PORT}`);
});
